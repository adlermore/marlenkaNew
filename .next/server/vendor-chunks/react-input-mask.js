/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-input-mask";
exports.ids = ["vendor-chunks/react-input-mask"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-input-mask/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-input-mask/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./lib/react-input-mask.development.js */ \"(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29sZC1jZW50ZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcz82NTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVhY3QtaW5wdXQtbWFzay5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZWFjdC1pbnB1dC1tYXNrLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-input-mask/lib/react-input-mask.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = _interopDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar invariant = _interopDefault(__webpack_require__(/*! invariant */ \"(ssr)/./node_modules/invariant/invariant.js\"));\nvar warning = _interopDefault(__webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\"));\n\nfunction _defaults2(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults2(subClass, superClass);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction setInputSelection(input, start, end) {\n  if ('selectionStart' in input && 'selectionEnd' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = end;\n  } else {\n    var range = input.createTextRange();\n    range.collapse(true);\n    range.moveStart('character', start);\n    range.moveEnd('character', end - start);\n    range.select();\n  }\n}\nfunction getInputSelection(input) {\n  var start = 0;\n  var end = 0;\n\n  if ('selectionStart' in input && 'selectionEnd' in input) {\n    start = input.selectionStart;\n    end = input.selectionEnd;\n  } else {\n    var range = document.selection.createRange();\n\n    if (range.parentElement() === input) {\n      start = -range.moveStart('character', -input.value.length);\n      end = -range.moveEnd('character', -input.value.length);\n    }\n  }\n\n  return {\n    start: start,\n    end: end,\n    length: end - start\n  };\n}\n\nvar defaultFormatChars = {\n  '9': '[0-9]',\n  'a': '[A-Za-z]',\n  '*': '[A-Za-z0-9]'\n};\nvar defaultMaskChar = '_';\n\nfunction parseMask (mask, maskChar, formatChars) {\n  var parsedMaskString = '';\n  var prefix = '';\n  var lastEditablePosition = null;\n  var permanents = [];\n\n  if (maskChar === undefined) {\n    maskChar = defaultMaskChar;\n  }\n\n  if (formatChars == null) {\n    formatChars = defaultFormatChars;\n  }\n\n  if (!mask || typeof mask !== 'string') {\n    return {\n      maskChar: maskChar,\n      formatChars: formatChars,\n      mask: null,\n      prefix: null,\n      lastEditablePosition: null,\n      permanents: []\n    };\n  }\n\n  var isPermanent = false;\n  mask.split('').forEach(function (character) {\n    if (!isPermanent && character === '\\\\') {\n      isPermanent = true;\n    } else {\n      if (isPermanent || !formatChars[character]) {\n        permanents.push(parsedMaskString.length);\n\n        if (parsedMaskString.length === permanents.length - 1) {\n          prefix += character;\n        }\n      } else {\n        lastEditablePosition = parsedMaskString.length + 1;\n      }\n\n      parsedMaskString += character;\n      isPermanent = false;\n    }\n  });\n  return {\n    maskChar: maskChar,\n    formatChars: formatChars,\n    prefix: prefix,\n    mask: parsedMaskString,\n    lastEditablePosition: lastEditablePosition,\n    permanents: permanents\n  };\n}\n\n/* eslint no-use-before-define: [\"error\", { functions: false }] */\nfunction isPermanentCharacter(maskOptions, pos) {\n  return maskOptions.permanents.indexOf(pos) !== -1;\n}\nfunction isAllowedCharacter(maskOptions, pos, character) {\n  var mask = maskOptions.mask,\n      formatChars = maskOptions.formatChars;\n\n  if (!character) {\n    return false;\n  }\n\n  if (isPermanentCharacter(maskOptions, pos)) {\n    return mask[pos] === character;\n  }\n\n  var ruleChar = mask[pos];\n  var charRule = formatChars[ruleChar];\n  return new RegExp(charRule).test(character);\n}\nfunction isEmpty(maskOptions, value) {\n  return value.split('').every(function (character, i) {\n    return isPermanentCharacter(maskOptions, i) || !isAllowedCharacter(maskOptions, i, character);\n  });\n}\nfunction getFilledLength(maskOptions, value) {\n  var maskChar = maskOptions.maskChar,\n      prefix = maskOptions.prefix;\n\n  if (!maskChar) {\n    while (value.length > prefix.length && isPermanentCharacter(maskOptions, value.length - 1)) {\n      value = value.slice(0, value.length - 1);\n    }\n\n    return value.length;\n  }\n\n  var filledLength = prefix.length;\n\n  for (var i = value.length; i >= prefix.length; i--) {\n    var character = value[i];\n    var isEnteredCharacter = !isPermanentCharacter(maskOptions, i) && isAllowedCharacter(maskOptions, i, character);\n\n    if (isEnteredCharacter) {\n      filledLength = i + 1;\n      break;\n    }\n  }\n\n  return filledLength;\n}\nfunction isFilled(maskOptions, value) {\n  return getFilledLength(maskOptions, value) === maskOptions.mask.length;\n}\nfunction formatValue(maskOptions, value) {\n  var maskChar = maskOptions.maskChar,\n      mask = maskOptions.mask,\n      prefix = maskOptions.prefix;\n\n  if (!maskChar) {\n    value = insertString(maskOptions, '', value, 0);\n\n    if (value.length < prefix.length) {\n      value = prefix;\n    }\n\n    while (value.length < mask.length && isPermanentCharacter(maskOptions, value.length)) {\n      value += mask[value.length];\n    }\n\n    return value;\n  }\n\n  if (value) {\n    var emptyValue = formatValue(maskOptions, '');\n    return insertString(maskOptions, emptyValue, value, 0);\n  }\n\n  for (var i = 0; i < mask.length; i++) {\n    if (isPermanentCharacter(maskOptions, i)) {\n      value += mask[i];\n    } else {\n      value += maskChar;\n    }\n  }\n\n  return value;\n}\nfunction clearRange(maskOptions, value, start, len) {\n  var end = start + len;\n  var maskChar = maskOptions.maskChar,\n      mask = maskOptions.mask,\n      prefix = maskOptions.prefix;\n  var arrayValue = value.split('');\n\n  if (!maskChar) {\n    // remove any permanent chars after clear range, they will be added back by formatValue\n    for (var i = end; i < arrayValue.length; i++) {\n      if (isPermanentCharacter(maskOptions, i)) {\n        arrayValue[i] = '';\n      }\n    }\n\n    start = Math.max(prefix.length, start);\n    arrayValue.splice(start, end - start);\n    value = arrayValue.join('');\n    return formatValue(maskOptions, value);\n  }\n\n  return arrayValue.map(function (character, i) {\n    if (i < start || i >= end) {\n      return character;\n    }\n\n    if (isPermanentCharacter(maskOptions, i)) {\n      return mask[i];\n    }\n\n    return maskChar;\n  }).join('');\n}\nfunction insertString(maskOptions, value, insertStr, insertPosition) {\n  var mask = maskOptions.mask,\n      maskChar = maskOptions.maskChar,\n      prefix = maskOptions.prefix;\n  var arrayInsertStr = insertStr.split('');\n  var isInputFilled = isFilled(maskOptions, value);\n\n  var isUsablePosition = function isUsablePosition(pos, character) {\n    return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];\n  };\n\n  var isUsableCharacter = function isUsableCharacter(character, pos) {\n    return !maskChar || !isPermanentCharacter(maskOptions, pos) || character !== maskChar;\n  };\n\n  if (!maskChar && insertPosition > value.length) {\n    value += mask.slice(value.length, insertPosition);\n  }\n\n  arrayInsertStr.every(function (insertCharacter) {\n    while (!isUsablePosition(insertPosition, insertCharacter)) {\n      if (insertPosition >= value.length) {\n        value += mask[insertPosition];\n      }\n\n      if (!isUsableCharacter(insertCharacter, insertPosition)) {\n        return true;\n      }\n\n      insertPosition++; // stop iteration if maximum value length reached\n\n      if (insertPosition >= mask.length) {\n        return false;\n      }\n    }\n\n    var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;\n\n    if (!isAllowed) {\n      return true;\n    }\n\n    if (insertPosition < value.length) {\n      if (maskChar || isInputFilled || insertPosition < prefix.length) {\n        value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition + 1);\n      } else {\n        value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition);\n        value = formatValue(maskOptions, value);\n      }\n    } else if (!maskChar) {\n      value += insertCharacter;\n    }\n\n    insertPosition++; // stop iteration if maximum value length reached\n\n    return insertPosition < mask.length;\n  });\n  return value;\n}\nfunction getInsertStringLength(maskOptions, value, insertStr, insertPosition) {\n  var mask = maskOptions.mask,\n      maskChar = maskOptions.maskChar;\n  var arrayInsertStr = insertStr.split('');\n  var initialInsertPosition = insertPosition;\n\n  var isUsablePosition = function isUsablePosition(pos, character) {\n    return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];\n  };\n\n  arrayInsertStr.every(function (insertCharacter) {\n    while (!isUsablePosition(insertPosition, insertCharacter)) {\n      insertPosition++; // stop iteration if maximum value length reached\n\n      if (insertPosition >= mask.length) {\n        return false;\n      }\n    }\n\n    var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;\n\n    if (isAllowed) {\n      insertPosition++;\n    } // stop iteration if maximum value length reached\n\n\n    return insertPosition < mask.length;\n  });\n  return insertPosition - initialInsertPosition;\n}\nfunction getLeftEditablePosition(maskOptions, pos) {\n  for (var i = pos; i >= 0; --i) {\n    if (!isPermanentCharacter(maskOptions, i)) {\n      return i;\n    }\n  }\n\n  return null;\n}\nfunction getRightEditablePosition(maskOptions, pos) {\n  var mask = maskOptions.mask;\n\n  for (var i = pos; i < mask.length; ++i) {\n    if (!isPermanentCharacter(maskOptions, i)) {\n      return i;\n    }\n  }\n\n  return null;\n}\nfunction getStringValue(value) {\n  return !value && value !== 0 ? '' : value + '';\n}\n\nfunction processChange(maskOptions, value, selection, previousValue, previousSelection) {\n  var mask = maskOptions.mask,\n      prefix = maskOptions.prefix,\n      lastEditablePosition = maskOptions.lastEditablePosition;\n  var newValue = value;\n  var enteredString = '';\n  var formattedEnteredStringLength = 0;\n  var removedLength = 0;\n  var cursorPosition = Math.min(previousSelection.start, selection.start);\n\n  if (selection.end > previousSelection.start) {\n    enteredString = newValue.slice(previousSelection.start, selection.end);\n    formattedEnteredStringLength = getInsertStringLength(maskOptions, previousValue, enteredString, cursorPosition);\n\n    if (!formattedEnteredStringLength) {\n      removedLength = 0;\n    } else {\n      removedLength = previousSelection.length;\n    }\n  } else if (newValue.length < previousValue.length) {\n    removedLength = previousValue.length - newValue.length;\n  }\n\n  newValue = previousValue;\n\n  if (removedLength) {\n    if (removedLength === 1 && !previousSelection.length) {\n      var deleteFromRight = previousSelection.start === selection.start;\n      cursorPosition = deleteFromRight ? getRightEditablePosition(maskOptions, selection.start) : getLeftEditablePosition(maskOptions, selection.start);\n    }\n\n    newValue = clearRange(maskOptions, newValue, cursorPosition, removedLength);\n  }\n\n  newValue = insertString(maskOptions, newValue, enteredString, cursorPosition);\n  cursorPosition = cursorPosition + formattedEnteredStringLength;\n\n  if (cursorPosition >= mask.length) {\n    cursorPosition = mask.length;\n  } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {\n    cursorPosition = prefix.length;\n  } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {\n    cursorPosition = getRightEditablePosition(maskOptions, cursorPosition);\n  }\n\n  newValue = formatValue(maskOptions, newValue);\n\n  if (!enteredString) {\n    enteredString = null;\n  }\n\n  return {\n    value: newValue,\n    enteredString: enteredString,\n    selection: {\n      start: cursorPosition,\n      end: cursorPosition\n    }\n  };\n}\n\nfunction isWindowsPhoneBrowser() {\n  var windows = new RegExp('windows', 'i');\n  var phone = new RegExp('phone', 'i');\n  var ua = navigator.userAgent;\n  return windows.test(ua) && phone.test(ua);\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction getRequestAnimationFrame() {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n}\n\nfunction getCancelAnimationFrame() {\n  return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;\n}\n\nfunction defer(fn) {\n  var hasCancelAnimationFrame = !!getCancelAnimationFrame();\n  var deferFn;\n\n  if (hasCancelAnimationFrame) {\n    deferFn = getRequestAnimationFrame();\n  } else {\n    deferFn = function deferFn() {\n      return setTimeout(fn, 1000 / 60);\n    };\n  }\n\n  return deferFn(fn);\n}\nfunction cancelDefer(deferId) {\n  var cancelFn = getCancelAnimationFrame() || clearTimeout;\n  cancelFn(deferId);\n}\n\nvar InputElement =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(InputElement, _React$Component);\n\n  function InputElement(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.focused = false;\n    _this.mounted = false;\n    _this.previousSelection = null;\n    _this.selectionDeferId = null;\n    _this.saveSelectionLoopDeferId = null;\n\n    _this.saveSelectionLoop = function () {\n      _this.previousSelection = _this.getSelection();\n      _this.saveSelectionLoopDeferId = defer(_this.saveSelectionLoop);\n    };\n\n    _this.runSaveSelectionLoop = function () {\n      if (_this.saveSelectionLoopDeferId === null) {\n        _this.saveSelectionLoop();\n      }\n    };\n\n    _this.stopSaveSelectionLoop = function () {\n      if (_this.saveSelectionLoopDeferId !== null) {\n        cancelDefer(_this.saveSelectionLoopDeferId);\n        _this.saveSelectionLoopDeferId = null;\n        _this.previousSelection = null;\n      }\n    };\n\n    _this.getInputDOMNode = function () {\n      if (!_this.mounted) {\n        return null;\n      }\n\n      var input = reactDom.findDOMNode(_assertThisInitialized(_assertThisInitialized(_this)));\n      var isDOMNode = typeof window !== 'undefined' && input instanceof window.Element; // workaround for react-test-renderer\n      // https://github.com/sanniassin/react-input-mask/issues/147\n\n      if (input && !isDOMNode) {\n        return null;\n      }\n\n      if (input.nodeName !== 'INPUT') {\n        input = input.querySelector('input');\n      }\n\n      if (!input) {\n        throw new Error('react-input-mask: inputComponent doesn\\'t contain input node');\n      }\n\n      return input;\n    };\n\n    _this.getInputValue = function () {\n      var input = _this.getInputDOMNode();\n\n      if (!input) {\n        return null;\n      }\n\n      return input.value;\n    };\n\n    _this.setInputValue = function (value) {\n      var input = _this.getInputDOMNode();\n\n      if (!input) {\n        return;\n      }\n\n      _this.value = value;\n      input.value = value;\n    };\n\n    _this.setCursorToEnd = function () {\n      var filledLength = getFilledLength(_this.maskOptions, _this.value);\n      var pos = getRightEditablePosition(_this.maskOptions, filledLength);\n\n      if (pos !== null) {\n        _this.setCursorPosition(pos);\n      }\n    };\n\n    _this.setSelection = function (start, end, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var input = _this.getInputDOMNode();\n\n      var isFocused = _this.isFocused(); // don't change selection on unfocused input\n      // because Safari sets focus on selection change (#154)\n\n\n      if (!input || !isFocused) {\n        return;\n      }\n\n      var _options = options,\n          deferred = _options.deferred;\n\n      if (!deferred) {\n        setInputSelection(input, start, end);\n      }\n\n      if (_this.selectionDeferId !== null) {\n        cancelDefer(_this.selectionDeferId);\n      } // deferred selection update is required for pre-Lollipop Android browser,\n      // but for consistent behavior we do it for all browsers\n\n\n      _this.selectionDeferId = defer(function () {\n        _this.selectionDeferId = null;\n        setInputSelection(input, start, end);\n      });\n      _this.previousSelection = {\n        start: start,\n        end: end,\n        length: Math.abs(end - start)\n      };\n    };\n\n    _this.getSelection = function () {\n      var input = _this.getInputDOMNode();\n\n      return getInputSelection(input);\n    };\n\n    _this.getCursorPosition = function () {\n      return _this.getSelection().start;\n    };\n\n    _this.setCursorPosition = function (pos) {\n      _this.setSelection(pos, pos);\n    };\n\n    _this.isFocused = function () {\n      return _this.focused;\n    };\n\n    _this.getBeforeMaskedValueChangeConfig = function () {\n      var _this$maskOptions = _this.maskOptions,\n          mask = _this$maskOptions.mask,\n          maskChar = _this$maskOptions.maskChar,\n          permanents = _this$maskOptions.permanents,\n          formatChars = _this$maskOptions.formatChars;\n      var alwaysShowMask = _this.props.alwaysShowMask;\n      return {\n        mask: mask,\n        maskChar: maskChar,\n        permanents: permanents,\n        alwaysShowMask: !!alwaysShowMask,\n        formatChars: formatChars\n      };\n    };\n\n    _this.isInputAutofilled = function (value, selection, previousValue, previousSelection) {\n      var input = _this.getInputDOMNode(); // only check for positive match because it will be false negative\n      // in case of autofill simulation in tests\n      //\n      // input.matches throws an exception if selector isn't supported\n\n\n      try {\n        if (input.matches(':-webkit-autofill')) {\n          return true;\n        }\n      } catch (e) {} // if input isn't focused then change event must have been triggered\n      // either by autofill or event simulation in tests\n\n\n      if (!_this.focused) {\n        return true;\n      } // if cursor has moved to the end while previousSelection forbids it\n      // then it must be autofill\n\n\n      return previousSelection.end < previousValue.length && selection.end === value.length;\n    };\n\n    _this.onChange = function (event) {\n      var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),\n          beforePasteState = _assertThisInitialize.beforePasteState;\n\n      var _assertThisInitialize2 = _assertThisInitialized(_assertThisInitialized(_this)),\n          previousSelection = _assertThisInitialize2.previousSelection;\n\n      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n\n      var value = _this.getInputValue();\n\n      var previousValue = _this.value;\n\n      var selection = _this.getSelection(); // autofill replaces entire value, ignore old one\n      // https://github.com/sanniassin/react-input-mask/issues/113\n\n\n      if (_this.isInputAutofilled(value, selection, previousValue, previousSelection)) {\n        previousValue = formatValue(_this.maskOptions, '');\n        previousSelection = {\n          start: 0,\n          end: 0,\n          length: 0\n        };\n      } // set value and selection as if we haven't\n      // cleared input in onPaste handler\n\n\n      if (beforePasteState) {\n        previousSelection = beforePasteState.selection;\n        previousValue = beforePasteState.value;\n        selection = {\n          start: previousSelection.start + value.length,\n          end: previousSelection.start + value.length,\n          length: 0\n        };\n        value = previousValue.slice(0, previousSelection.start) + value + previousValue.slice(previousSelection.end);\n        _this.beforePasteState = null;\n      }\n\n      var changedState = processChange(_this.maskOptions, value, selection, previousValue, previousSelection);\n      var enteredString = changedState.enteredString;\n      var newSelection = changedState.selection;\n      var newValue = changedState.value;\n\n      if (isFunction(beforeMaskedValueChange)) {\n        var modifiedValue = beforeMaskedValueChange({\n          value: newValue,\n          selection: newSelection\n        }, {\n          value: previousValue,\n          selection: previousSelection\n        }, enteredString, _this.getBeforeMaskedValueChangeConfig());\n        newValue = modifiedValue.value;\n        newSelection = modifiedValue.selection;\n      }\n\n      _this.setInputValue(newValue);\n\n      if (isFunction(_this.props.onChange)) {\n        _this.props.onChange(event);\n      }\n\n      if (_this.isWindowsPhoneBrowser) {\n        _this.setSelection(newSelection.start, newSelection.end, {\n          deferred: true\n        });\n      } else {\n        _this.setSelection(newSelection.start, newSelection.end);\n      }\n    };\n\n    _this.onFocus = function (event) {\n      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n      var _this$maskOptions2 = _this.maskOptions,\n          mask = _this$maskOptions2.mask,\n          prefix = _this$maskOptions2.prefix;\n      _this.focused = true; // if autoFocus is set, onFocus triggers before componentDidMount\n\n      _this.mounted = true;\n\n      if (mask) {\n        if (!_this.value) {\n          var emptyValue = formatValue(_this.maskOptions, prefix);\n          var newValue = formatValue(_this.maskOptions, emptyValue);\n          var filledLength = getFilledLength(_this.maskOptions, newValue);\n          var cursorPosition = getRightEditablePosition(_this.maskOptions, filledLength);\n          var newSelection = {\n            start: cursorPosition,\n            end: cursorPosition\n          };\n\n          if (isFunction(beforeMaskedValueChange)) {\n            var modifiedValue = beforeMaskedValueChange({\n              value: newValue,\n              selection: newSelection\n            }, {\n              value: _this.value,\n              selection: null\n            }, null, _this.getBeforeMaskedValueChangeConfig());\n            newValue = modifiedValue.value;\n            newSelection = modifiedValue.selection;\n          }\n\n          var isInputValueChanged = newValue !== _this.getInputValue();\n\n          if (isInputValueChanged) {\n            _this.setInputValue(newValue);\n          }\n\n          if (isInputValueChanged && isFunction(_this.props.onChange)) {\n            _this.props.onChange(event);\n          }\n\n          _this.setSelection(newSelection.start, newSelection.end);\n        } else if (getFilledLength(_this.maskOptions, _this.value) < _this.maskOptions.mask.length) {\n          _this.setCursorToEnd();\n        }\n\n        _this.runSaveSelectionLoop();\n      }\n\n      if (isFunction(_this.props.onFocus)) {\n        _this.props.onFocus(event);\n      }\n    };\n\n    _this.onBlur = function (event) {\n      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n      var mask = _this.maskOptions.mask;\n\n      _this.stopSaveSelectionLoop();\n\n      _this.focused = false;\n\n      if (mask && !_this.props.alwaysShowMask && isEmpty(_this.maskOptions, _this.value)) {\n        var newValue = '';\n\n        if (isFunction(beforeMaskedValueChange)) {\n          var modifiedValue = beforeMaskedValueChange({\n            value: newValue,\n            selection: null\n          }, {\n            value: _this.value,\n            selection: _this.previousSelection\n          }, null, _this.getBeforeMaskedValueChangeConfig());\n          newValue = modifiedValue.value;\n        }\n\n        var isInputValueChanged = newValue !== _this.getInputValue();\n\n        if (isInputValueChanged) {\n          _this.setInputValue(newValue);\n        }\n\n        if (isInputValueChanged && isFunction(_this.props.onChange)) {\n          _this.props.onChange(event);\n        }\n      }\n\n      if (isFunction(_this.props.onBlur)) {\n        _this.props.onBlur(event);\n      }\n    };\n\n    _this.onMouseDown = function (event) {\n      // tiny unintentional mouse movements can break cursor\n      // position on focus, so we have to restore it in that case\n      //\n      // https://github.com/sanniassin/react-input-mask/issues/108\n      if (!_this.focused && document.addEventListener) {\n        _this.mouseDownX = event.clientX;\n        _this.mouseDownY = event.clientY;\n        _this.mouseDownTime = new Date().getTime();\n\n        var mouseUpHandler = function mouseUpHandler(mouseUpEvent) {\n          document.removeEventListener('mouseup', mouseUpHandler);\n\n          if (!_this.focused) {\n            return;\n          }\n\n          var deltaX = Math.abs(mouseUpEvent.clientX - _this.mouseDownX);\n          var deltaY = Math.abs(mouseUpEvent.clientY - _this.mouseDownY);\n          var axisDelta = Math.max(deltaX, deltaY);\n\n          var timeDelta = new Date().getTime() - _this.mouseDownTime;\n\n          if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {\n            _this.setCursorToEnd();\n          }\n        };\n\n        document.addEventListener('mouseup', mouseUpHandler);\n      }\n\n      if (isFunction(_this.props.onMouseDown)) {\n        _this.props.onMouseDown(event);\n      }\n    };\n\n    _this.onPaste = function (event) {\n      if (isFunction(_this.props.onPaste)) {\n        _this.props.onPaste(event);\n      } // event.clipboardData might not work in Android browser\n      // cleaning input to get raw text inside onChange handler\n\n\n      if (!event.defaultPrevented) {\n        _this.beforePasteState = {\n          value: _this.getInputValue(),\n          selection: _this.getSelection()\n        };\n\n        _this.setInputValue('');\n      }\n    };\n\n    _this.handleRef = function (ref) {\n      if (_this.props.children == null && isFunction(_this.props.inputRef)) {\n        _this.props.inputRef(ref);\n      }\n    };\n\n    var _mask = props.mask,\n        _maskChar = props.maskChar,\n        _formatChars = props.formatChars,\n        _alwaysShowMask = props.alwaysShowMask,\n        _beforeMaskedValueChange = props.beforeMaskedValueChange;\n    var defaultValue = props.defaultValue,\n        _value = props.value;\n    _this.maskOptions = parseMask(_mask, _maskChar, _formatChars);\n\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n\n    if (_value == null) {\n      _value = defaultValue;\n    }\n\n    var _newValue = getStringValue(_value);\n\n    if (_this.maskOptions.mask && (_alwaysShowMask || _newValue)) {\n      _newValue = formatValue(_this.maskOptions, _newValue);\n\n      if (isFunction(_beforeMaskedValueChange)) {\n        var oldValue = props.value;\n\n        if (props.value == null) {\n          oldValue = defaultValue;\n        }\n\n        oldValue = getStringValue(oldValue);\n\n        var modifiedValue = _beforeMaskedValueChange({\n          value: _newValue,\n          selection: null\n        }, {\n          value: oldValue,\n          selection: null\n        }, null, _this.getBeforeMaskedValueChangeConfig());\n\n        _newValue = modifiedValue.value;\n      }\n    }\n\n    _this.value = _newValue;\n    return _this;\n  }\n\n  var _proto = InputElement.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.mounted = true; // workaround for react-test-renderer\n    // https://github.com/sanniassin/react-input-mask/issues/147\n\n    if (!this.getInputDOMNode()) {\n      return;\n    }\n\n    this.isWindowsPhoneBrowser = isWindowsPhoneBrowser();\n\n    if (this.maskOptions.mask && this.getInputValue() !== this.value) {\n      this.setInputValue(this.value);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    var previousSelection = this.previousSelection;\n    var _this$props = this.props,\n        beforeMaskedValueChange = _this$props.beforeMaskedValueChange,\n        alwaysShowMask = _this$props.alwaysShowMask,\n        mask = _this$props.mask,\n        maskChar = _this$props.maskChar,\n        formatChars = _this$props.formatChars;\n    var previousMaskOptions = this.maskOptions;\n    var showEmpty = alwaysShowMask || this.isFocused();\n    var hasValue = this.props.value != null;\n    var newValue = hasValue ? getStringValue(this.props.value) : this.value;\n    var cursorPosition = previousSelection ? previousSelection.start : null;\n    this.maskOptions = parseMask(mask, maskChar, formatChars);\n\n    if (!this.maskOptions.mask) {\n      if (previousMaskOptions.mask) {\n        this.stopSaveSelectionLoop(); // render depends on this.maskOptions and this.value,\n        // call forceUpdate to keep it in sync\n\n        this.forceUpdate();\n      }\n\n      return;\n    } else if (!previousMaskOptions.mask && this.isFocused()) {\n      this.runSaveSelectionLoop();\n    }\n\n    var isMaskChanged = this.maskOptions.mask && this.maskOptions.mask !== previousMaskOptions.mask;\n\n    if (!previousMaskOptions.mask && !hasValue) {\n      newValue = this.getInputValue();\n    }\n\n    if (isMaskChanged || this.maskOptions.mask && (newValue || showEmpty)) {\n      newValue = formatValue(this.maskOptions, newValue);\n    }\n\n    if (isMaskChanged) {\n      var filledLength = getFilledLength(this.maskOptions, newValue);\n\n      if (cursorPosition === null || filledLength < cursorPosition) {\n        if (isFilled(this.maskOptions, newValue)) {\n          cursorPosition = filledLength;\n        } else {\n          cursorPosition = getRightEditablePosition(this.maskOptions, filledLength);\n        }\n      }\n    }\n\n    if (this.maskOptions.mask && isEmpty(this.maskOptions, newValue) && !showEmpty && (!hasValue || !this.props.value)) {\n      newValue = '';\n    }\n\n    var newSelection = {\n      start: cursorPosition,\n      end: cursorPosition\n    };\n\n    if (isFunction(beforeMaskedValueChange)) {\n      var modifiedValue = beforeMaskedValueChange({\n        value: newValue,\n        selection: newSelection\n      }, {\n        value: this.value,\n        selection: this.previousSelection\n      }, null, this.getBeforeMaskedValueChangeConfig());\n      newValue = modifiedValue.value;\n      newSelection = modifiedValue.selection;\n    }\n\n    this.value = newValue;\n    var isValueChanged = this.getInputValue() !== this.value; // render depends on this.maskOptions and this.value,\n    // call forceUpdate to keep it in sync\n\n    if (isValueChanged) {\n      this.setInputValue(this.value);\n      this.forceUpdate();\n    } else if (isMaskChanged) {\n      this.forceUpdate();\n    }\n\n    var isSelectionChanged = false;\n\n    if (newSelection.start != null && newSelection.end != null) {\n      isSelectionChanged = !previousSelection || previousSelection.start !== newSelection.start || previousSelection.end !== newSelection.end;\n    }\n\n    if (isSelectionChanged || isValueChanged) {\n      this.setSelection(newSelection.start, newSelection.end);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.mounted = false;\n\n    if (this.selectionDeferId !== null) {\n      cancelDefer(this.selectionDeferId);\n    }\n\n    this.stopSaveSelectionLoop();\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        mask = _this$props2.mask,\n        alwaysShowMask = _this$props2.alwaysShowMask,\n        maskChar = _this$props2.maskChar,\n        formatChars = _this$props2.formatChars,\n        inputRef = _this$props2.inputRef,\n        beforeMaskedValueChange = _this$props2.beforeMaskedValueChange,\n        children = _this$props2.children,\n        restProps = _objectWithoutPropertiesLoose(_this$props2, [\"mask\", \"alwaysShowMask\", \"maskChar\", \"formatChars\", \"inputRef\", \"beforeMaskedValueChange\", \"children\"]);\n\n    var inputElement;\n     true ? warning( // parse mask to test against actual mask prop as this.maskOptions\n    // will be updated later in componentDidUpdate\n    !restProps.maxLength || !parseMask(mask, maskChar, formatChars).mask, 'react-input-mask: maxLength property shouldn\\'t be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length.') : 0;\n\n    if (children) {\n      !isFunction(children) ?  true ? invariant(false, 'react-input-mask: children must be a function') : 0 : void 0;\n      var controlledProps = ['onChange', 'onPaste', 'onMouseDown', 'onFocus', 'onBlur', 'value', 'disabled', 'readOnly'];\n\n      var childrenProps = _extends({}, restProps);\n\n      controlledProps.forEach(function (propId) {\n        return delete childrenProps[propId];\n      });\n      inputElement = children(childrenProps);\n      var conflictProps = controlledProps.filter(function (propId) {\n        return inputElement.props[propId] != null && inputElement.props[propId] !== restProps[propId];\n      });\n      !!conflictProps.length ?  true ? invariant(false, \"react-input-mask: the following props should be passed to the react-input-mask's component and should not be altered in children's function: \" + conflictProps.join(', ')) : 0 : void 0;\n       true ? warning(!inputRef, 'react-input-mask: inputRef is ignored when children is passed, attach ref to the children instead') : 0;\n    } else {\n      inputElement = React.createElement(\"input\", _extends({\n        ref: this.handleRef\n      }, restProps));\n    }\n\n    var changedProps = {\n      onFocus: this.onFocus,\n      onBlur: this.onBlur\n    };\n\n    if (this.maskOptions.mask) {\n      if (!restProps.disabled && !restProps.readOnly) {\n        changedProps.onChange = this.onChange;\n        changedProps.onPaste = this.onPaste;\n        changedProps.onMouseDown = this.onMouseDown;\n      }\n\n      if (restProps.value != null) {\n        changedProps.value = this.value;\n      }\n    }\n\n    inputElement = React.cloneElement(inputElement, changedProps);\n    return inputElement;\n  };\n\n  return InputElement;\n}(React.Component);\n\nmodule.exports = InputElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7O0FBRWhDLDRCQUE0QixtQkFBTyxDQUFDLHdHQUFPO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxnSEFBVztBQUNsQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBVztBQUNuRCw4QkFBOEIsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0MscUNBQXFDLGlEQUFpRCxnQkFBZ0IsaUJBQWlCLE9BQU8sbUJBQW1CLDREQUE0RCw2REFBNkQsNENBQTRDOztBQUV0VDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEM7QUFDNUM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0EsOE9BQThPLENBQU07O0FBRXBQO0FBQ0EsOEJBQThCLEtBQXFDLHVFQUF1RSxDQUFnQjtBQUMxSjs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLCtCQUErQixLQUFxQyxrTUFBa00sQ0FBZ0I7QUFDdFIsTUFBTSxLQUFxQyw2SEFBNkgsQ0FBTTtBQUM5SyxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dvbGQtY2VudGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LW1hc2svbGliL3JlYWN0LWlucHV0LW1hc2suZGV2ZWxvcG1lbnQuanM/NjJhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgUmVhY3QgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmVhY3QnKSk7XG52YXIgcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBpbnZhcmlhbnQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaW52YXJpYW50JykpO1xudmFyIHdhcm5pbmcgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnd2FybmluZycpKTtcblxuZnVuY3Rpb24gX2RlZmF1bHRzMihvYmosIGRlZmF1bHRzKSB7IHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpOyBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHsgdmFyIGtleSA9IGtleXNbaV07IHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7IGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTsgfSB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9kZWZhdWx0czIoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gc2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQgJiYgJ3NlbGVjdGlvbkVuZCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgcmFuZ2Uuc2VsZWN0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0U2VsZWN0aW9uKGlucHV0KSB7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0ICYmICdzZWxlY3Rpb25FbmQnIGluIGlucHV0KSB7XG4gICAgc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICBlbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG5cbiAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgc3RhcnQgPSAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIGVuZCA9IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZCxcbiAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5cbnZhciBkZWZhdWx0Rm9ybWF0Q2hhcnMgPSB7XG4gICc5JzogJ1swLTldJyxcbiAgJ2EnOiAnW0EtWmEtel0nLFxuICAnKic6ICdbQS1aYS16MC05XSdcbn07XG52YXIgZGVmYXVsdE1hc2tDaGFyID0gJ18nO1xuXG5mdW5jdGlvbiBwYXJzZU1hc2sgKG1hc2ssIG1hc2tDaGFyLCBmb3JtYXRDaGFycykge1xuICB2YXIgcGFyc2VkTWFza1N0cmluZyA9ICcnO1xuICB2YXIgcHJlZml4ID0gJyc7XG4gIHZhciBsYXN0RWRpdGFibGVQb3NpdGlvbiA9IG51bGw7XG4gIHZhciBwZXJtYW5lbnRzID0gW107XG5cbiAgaWYgKG1hc2tDaGFyID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXNrQ2hhciA9IGRlZmF1bHRNYXNrQ2hhcjtcbiAgfVxuXG4gIGlmIChmb3JtYXRDaGFycyA9PSBudWxsKSB7XG4gICAgZm9ybWF0Q2hhcnMgPSBkZWZhdWx0Rm9ybWF0Q2hhcnM7XG4gIH1cblxuICBpZiAoIW1hc2sgfHwgdHlwZW9mIG1hc2sgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hc2tDaGFyOiBtYXNrQ2hhcixcbiAgICAgIGZvcm1hdENoYXJzOiBmb3JtYXRDaGFycyxcbiAgICAgIG1hc2s6IG51bGwsXG4gICAgICBwcmVmaXg6IG51bGwsXG4gICAgICBsYXN0RWRpdGFibGVQb3NpdGlvbjogbnVsbCxcbiAgICAgIHBlcm1hbmVudHM6IFtdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc1Blcm1hbmVudCA9IGZhbHNlO1xuICBtYXNrLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICBpZiAoIWlzUGVybWFuZW50ICYmIGNoYXJhY3RlciA9PT0gJ1xcXFwnKSB7XG4gICAgICBpc1Blcm1hbmVudCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1Blcm1hbmVudCB8fCAhZm9ybWF0Q2hhcnNbY2hhcmFjdGVyXSkge1xuICAgICAgICBwZXJtYW5lbnRzLnB1c2gocGFyc2VkTWFza1N0cmluZy5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChwYXJzZWRNYXNrU3RyaW5nLmxlbmd0aCA9PT0gcGVybWFuZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcHJlZml4ICs9IGNoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdEVkaXRhYmxlUG9zaXRpb24gPSBwYXJzZWRNYXNrU3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZE1hc2tTdHJpbmcgKz0gY2hhcmFjdGVyO1xuICAgICAgaXNQZXJtYW5lbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1hc2tDaGFyOiBtYXNrQ2hhcixcbiAgICBmb3JtYXRDaGFyczogZm9ybWF0Q2hhcnMsXG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgbWFzazogcGFyc2VkTWFza1N0cmluZyxcbiAgICBsYXN0RWRpdGFibGVQb3NpdGlvbjogbGFzdEVkaXRhYmxlUG9zaXRpb24sXG4gICAgcGVybWFuZW50czogcGVybWFuZW50c1xuICB9O1xufVxuXG4vKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFtcImVycm9yXCIsIHsgZnVuY3Rpb25zOiBmYWxzZSB9XSAqL1xuZnVuY3Rpb24gaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcykge1xuICByZXR1cm4gbWFza09wdGlvbnMucGVybWFuZW50cy5pbmRleE9mKHBvcykgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNBbGxvd2VkQ2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MsIGNoYXJhY3Rlcikge1xuICB2YXIgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBmb3JtYXRDaGFycyA9IG1hc2tPcHRpb25zLmZvcm1hdENoYXJzO1xuXG4gIGlmICghY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MpKSB7XG4gICAgcmV0dXJuIG1hc2tbcG9zXSA9PT0gY2hhcmFjdGVyO1xuICB9XG5cbiAgdmFyIHJ1bGVDaGFyID0gbWFza1twb3NdO1xuICB2YXIgY2hhclJ1bGUgPSBmb3JtYXRDaGFyc1tydWxlQ2hhcl07XG4gIHJldHVybiBuZXcgUmVnRXhwKGNoYXJSdWxlKS50ZXN0KGNoYXJhY3Rlcik7XG59XG5mdW5jdGlvbiBpc0VtcHR5KG1hc2tPcHRpb25zLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoJycpLmV2ZXJ5KGZ1bmN0aW9uIChjaGFyYWN0ZXIsIGkpIHtcbiAgICByZXR1cm4gaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpIHx8ICFpc0FsbG93ZWRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGksIGNoYXJhY3Rlcik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmlsbGVkTGVuZ3RoKG1hc2tPcHRpb25zLCB2YWx1ZSkge1xuICB2YXIgbWFza0NoYXIgPSBtYXNrT3B0aW9ucy5tYXNrQ2hhcixcbiAgICAgIHByZWZpeCA9IG1hc2tPcHRpb25zLnByZWZpeDtcblxuICBpZiAoIW1hc2tDaGFyKSB7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA+IHByZWZpeC5sZW5ndGggJiYgaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHZhbHVlLmxlbmd0aCAtIDEpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gIH1cblxuICB2YXIgZmlsbGVkTGVuZ3RoID0gcHJlZml4Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gdmFsdWUubGVuZ3RoOyBpID49IHByZWZpeC5sZW5ndGg7IGktLSkge1xuICAgIHZhciBjaGFyYWN0ZXIgPSB2YWx1ZVtpXTtcbiAgICB2YXIgaXNFbnRlcmVkQ2hhcmFjdGVyID0gIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSAmJiBpc0FsbG93ZWRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGksIGNoYXJhY3Rlcik7XG5cbiAgICBpZiAoaXNFbnRlcmVkQ2hhcmFjdGVyKSB7XG4gICAgICBmaWxsZWRMZW5ndGggPSBpICsgMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWxsZWRMZW5ndGg7XG59XG5mdW5jdGlvbiBpc0ZpbGxlZChtYXNrT3B0aW9ucywgdmFsdWUpIHtcbiAgcmV0dXJuIGdldEZpbGxlZExlbmd0aChtYXNrT3B0aW9ucywgdmFsdWUpID09PSBtYXNrT3B0aW9ucy5tYXNrLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKG1hc2tPcHRpb25zLCB2YWx1ZSkge1xuICB2YXIgbWFza0NoYXIgPSBtYXNrT3B0aW9ucy5tYXNrQ2hhcixcbiAgICAgIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgcHJlZml4ID0gbWFza09wdGlvbnMucHJlZml4O1xuXG4gIGlmICghbWFza0NoYXIpIHtcbiAgICB2YWx1ZSA9IGluc2VydFN0cmluZyhtYXNrT3B0aW9ucywgJycsIHZhbHVlLCAwKTtcblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPCBwcmVmaXgubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IHByZWZpeDtcbiAgICB9XG5cbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbWFzay5sZW5ndGggJiYgaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgIHZhbHVlICs9IG1hc2tbdmFsdWUubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUpIHtcbiAgICB2YXIgZW1wdHlWYWx1ZSA9IGZvcm1hdFZhbHVlKG1hc2tPcHRpb25zLCAnJyk7XG4gICAgcmV0dXJuIGluc2VydFN0cmluZyhtYXNrT3B0aW9ucywgZW1wdHlWYWx1ZSwgdmFsdWUsIDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSkge1xuICAgICAgdmFsdWUgKz0gbWFza1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gbWFza0NoYXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2xlYXJSYW5nZShtYXNrT3B0aW9ucywgdmFsdWUsIHN0YXJ0LCBsZW4pIHtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgbGVuO1xuICB2YXIgbWFza0NoYXIgPSBtYXNrT3B0aW9ucy5tYXNrQ2hhcixcbiAgICAgIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgcHJlZml4ID0gbWFza09wdGlvbnMucHJlZml4O1xuICB2YXIgYXJyYXlWYWx1ZSA9IHZhbHVlLnNwbGl0KCcnKTtcblxuICBpZiAoIW1hc2tDaGFyKSB7XG4gICAgLy8gcmVtb3ZlIGFueSBwZXJtYW5lbnQgY2hhcnMgYWZ0ZXIgY2xlYXIgcmFuZ2UsIHRoZXkgd2lsbCBiZSBhZGRlZCBiYWNrIGJ5IGZvcm1hdFZhbHVlXG4gICAgZm9yICh2YXIgaSA9IGVuZDsgaSA8IGFycmF5VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkpIHtcbiAgICAgICAgYXJyYXlWYWx1ZVtpXSA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0ID0gTWF0aC5tYXgocHJlZml4Lmxlbmd0aCwgc3RhcnQpO1xuICAgIGFycmF5VmFsdWUuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgdmFsdWUgPSBhcnJheVZhbHVlLmpvaW4oJycpO1xuICAgIHJldHVybiBmb3JtYXRWYWx1ZShtYXNrT3B0aW9ucywgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5VmFsdWUubWFwKGZ1bmN0aW9uIChjaGFyYWN0ZXIsIGkpIHtcbiAgICBpZiAoaSA8IHN0YXJ0IHx8IGkgPj0gZW5kKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyO1xuICAgIH1cblxuICAgIGlmIChpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkpIHtcbiAgICAgIHJldHVybiBtYXNrW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBtYXNrQ2hhcjtcbiAgfSkuam9pbignJyk7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHJpbmcobWFza09wdGlvbnMsIHZhbHVlLCBpbnNlcnRTdHIsIGluc2VydFBvc2l0aW9uKSB7XG4gIHZhciBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIG1hc2tDaGFyID0gbWFza09wdGlvbnMubWFza0NoYXIsXG4gICAgICBwcmVmaXggPSBtYXNrT3B0aW9ucy5wcmVmaXg7XG4gIHZhciBhcnJheUluc2VydFN0ciA9IGluc2VydFN0ci5zcGxpdCgnJyk7XG4gIHZhciBpc0lucHV0RmlsbGVkID0gaXNGaWxsZWQobWFza09wdGlvbnMsIHZhbHVlKTtcblxuICB2YXIgaXNVc2FibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIGlzVXNhYmxlUG9zaXRpb24ocG9zLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MpIHx8IGNoYXJhY3RlciA9PT0gbWFza1twb3NdO1xuICB9O1xuXG4gIHZhciBpc1VzYWJsZUNoYXJhY3RlciA9IGZ1bmN0aW9uIGlzVXNhYmxlQ2hhcmFjdGVyKGNoYXJhY3RlciwgcG9zKSB7XG4gICAgcmV0dXJuICFtYXNrQ2hhciB8fCAhaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcykgfHwgY2hhcmFjdGVyICE9PSBtYXNrQ2hhcjtcbiAgfTtcblxuICBpZiAoIW1hc2tDaGFyICYmIGluc2VydFBvc2l0aW9uID4gdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgKz0gbWFzay5zbGljZSh2YWx1ZS5sZW5ndGgsIGluc2VydFBvc2l0aW9uKTtcbiAgfVxuXG4gIGFycmF5SW5zZXJ0U3RyLmV2ZXJ5KGZ1bmN0aW9uIChpbnNlcnRDaGFyYWN0ZXIpIHtcbiAgICB3aGlsZSAoIWlzVXNhYmxlUG9zaXRpb24oaW5zZXJ0UG9zaXRpb24sIGluc2VydENoYXJhY3RlcikpIHtcbiAgICAgIGlmIChpbnNlcnRQb3NpdGlvbiA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgKz0gbWFza1tpbnNlcnRQb3NpdGlvbl07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNVc2FibGVDaGFyYWN0ZXIoaW5zZXJ0Q2hhcmFjdGVyLCBpbnNlcnRQb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc2VydFBvc2l0aW9uKys7IC8vIHN0b3AgaXRlcmF0aW9uIGlmIG1heGltdW0gdmFsdWUgbGVuZ3RoIHJlYWNoZWRcblxuICAgICAgaWYgKGluc2VydFBvc2l0aW9uID49IG1hc2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNBbGxvd2VkID0gaXNBbGxvd2VkQ2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpbnNlcnRQb3NpdGlvbiwgaW5zZXJ0Q2hhcmFjdGVyKSB8fCBpbnNlcnRDaGFyYWN0ZXIgPT09IG1hc2tDaGFyO1xuXG4gICAgaWYgKCFpc0FsbG93ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbnNlcnRQb3NpdGlvbiA8IHZhbHVlLmxlbmd0aCkge1xuICAgICAgaWYgKG1hc2tDaGFyIHx8IGlzSW5wdXRGaWxsZWQgfHwgaW5zZXJ0UG9zaXRpb24gPCBwcmVmaXgubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaW5zZXJ0UG9zaXRpb24pICsgaW5zZXJ0Q2hhcmFjdGVyICsgdmFsdWUuc2xpY2UoaW5zZXJ0UG9zaXRpb24gKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaW5zZXJ0UG9zaXRpb24pICsgaW5zZXJ0Q2hhcmFjdGVyICsgdmFsdWUuc2xpY2UoaW5zZXJ0UG9zaXRpb24pO1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdFZhbHVlKG1hc2tPcHRpb25zLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbWFza0NoYXIpIHtcbiAgICAgIHZhbHVlICs9IGluc2VydENoYXJhY3RlcjtcbiAgICB9XG5cbiAgICBpbnNlcnRQb3NpdGlvbisrOyAvLyBzdG9wIGl0ZXJhdGlvbiBpZiBtYXhpbXVtIHZhbHVlIGxlbmd0aCByZWFjaGVkXG5cbiAgICByZXR1cm4gaW5zZXJ0UG9zaXRpb24gPCBtYXNrLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEluc2VydFN0cmluZ0xlbmd0aChtYXNrT3B0aW9ucywgdmFsdWUsIGluc2VydFN0ciwgaW5zZXJ0UG9zaXRpb24pIHtcbiAgdmFyIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0NoYXIgPSBtYXNrT3B0aW9ucy5tYXNrQ2hhcjtcbiAgdmFyIGFycmF5SW5zZXJ0U3RyID0gaW5zZXJ0U3RyLnNwbGl0KCcnKTtcbiAgdmFyIGluaXRpYWxJbnNlcnRQb3NpdGlvbiA9IGluc2VydFBvc2l0aW9uO1xuXG4gIHZhciBpc1VzYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gaXNVc2FibGVQb3NpdGlvbihwb3MsIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiAhaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcykgfHwgY2hhcmFjdGVyID09PSBtYXNrW3Bvc107XG4gIH07XG5cbiAgYXJyYXlJbnNlcnRTdHIuZXZlcnkoZnVuY3Rpb24gKGluc2VydENoYXJhY3Rlcikge1xuICAgIHdoaWxlICghaXNVc2FibGVQb3NpdGlvbihpbnNlcnRQb3NpdGlvbiwgaW5zZXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgaW5zZXJ0UG9zaXRpb24rKzsgLy8gc3RvcCBpdGVyYXRpb24gaWYgbWF4aW11bSB2YWx1ZSBsZW5ndGggcmVhY2hlZFxuXG4gICAgICBpZiAoaW5zZXJ0UG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0FsbG93ZWQgPSBpc0FsbG93ZWRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGluc2VydFBvc2l0aW9uLCBpbnNlcnRDaGFyYWN0ZXIpIHx8IGluc2VydENoYXJhY3RlciA9PT0gbWFza0NoYXI7XG5cbiAgICBpZiAoaXNBbGxvd2VkKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbisrO1xuICAgIH0gLy8gc3RvcCBpdGVyYXRpb24gaWYgbWF4aW11bSB2YWx1ZSBsZW5ndGggcmVhY2hlZFxuXG5cbiAgICByZXR1cm4gaW5zZXJ0UG9zaXRpb24gPCBtYXNrLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiBpbnNlcnRQb3NpdGlvbiAtIGluaXRpYWxJbnNlcnRQb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExlZnRFZGl0YWJsZVBvc2l0aW9uKG1hc2tPcHRpb25zLCBwb3MpIHtcbiAgZm9yICh2YXIgaSA9IHBvczsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24obWFza09wdGlvbnMsIHBvcykge1xuICB2YXIgbWFzayA9IG1hc2tPcHRpb25zLm1hc2s7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IG1hc2subGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlICYmIHZhbHVlICE9PSAwID8gJycgOiB2YWx1ZSArICcnO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hhbmdlKG1hc2tPcHRpb25zLCB2YWx1ZSwgc2VsZWN0aW9uLCBwcmV2aW91c1ZhbHVlLCBwcmV2aW91c1NlbGVjdGlvbikge1xuICB2YXIgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBwcmVmaXggPSBtYXNrT3B0aW9ucy5wcmVmaXgsXG4gICAgICBsYXN0RWRpdGFibGVQb3NpdGlvbiA9IG1hc2tPcHRpb25zLmxhc3RFZGl0YWJsZVBvc2l0aW9uO1xuICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgdmFyIGVudGVyZWRTdHJpbmcgPSAnJztcbiAgdmFyIGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGggPSAwO1xuICB2YXIgcmVtb3ZlZExlbmd0aCA9IDA7XG4gIHZhciBjdXJzb3JQb3NpdGlvbiA9IE1hdGgubWluKHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0LCBzZWxlY3Rpb24uc3RhcnQpO1xuXG4gIGlmIChzZWxlY3Rpb24uZW5kID4gcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQpIHtcbiAgICBlbnRlcmVkU3RyaW5nID0gbmV3VmFsdWUuc2xpY2UocHJldmlvdXNTZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpO1xuICAgIGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGggPSBnZXRJbnNlcnRTdHJpbmdMZW5ndGgobWFza09wdGlvbnMsIHByZXZpb3VzVmFsdWUsIGVudGVyZWRTdHJpbmcsIGN1cnNvclBvc2l0aW9uKTtcblxuICAgIGlmICghZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCkge1xuICAgICAgcmVtb3ZlZExlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZWRMZW5ndGggPSBwcmV2aW91c1NlbGVjdGlvbi5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5ld1ZhbHVlLmxlbmd0aCA8IHByZXZpb3VzVmFsdWUubGVuZ3RoKSB7XG4gICAgcmVtb3ZlZExlbmd0aCA9IHByZXZpb3VzVmFsdWUubGVuZ3RoIC0gbmV3VmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgbmV3VmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuXG4gIGlmIChyZW1vdmVkTGVuZ3RoKSB7XG4gICAgaWYgKHJlbW92ZWRMZW5ndGggPT09IDEgJiYgIXByZXZpb3VzU2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgdmFyIGRlbGV0ZUZyb21SaWdodCA9IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxlY3Rpb24uc3RhcnQ7XG4gICAgICBjdXJzb3JQb3NpdGlvbiA9IGRlbGV0ZUZyb21SaWdodCA/IGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihtYXNrT3B0aW9ucywgc2VsZWN0aW9uLnN0YXJ0KSA6IGdldExlZnRFZGl0YWJsZVBvc2l0aW9uKG1hc2tPcHRpb25zLCBzZWxlY3Rpb24uc3RhcnQpO1xuICAgIH1cblxuICAgIG5ld1ZhbHVlID0gY2xlYXJSYW5nZShtYXNrT3B0aW9ucywgbmV3VmFsdWUsIGN1cnNvclBvc2l0aW9uLCByZW1vdmVkTGVuZ3RoKTtcbiAgfVxuXG4gIG5ld1ZhbHVlID0gaW5zZXJ0U3RyaW5nKG1hc2tPcHRpb25zLCBuZXdWYWx1ZSwgZW50ZXJlZFN0cmluZywgY3Vyc29yUG9zaXRpb24pO1xuICBjdXJzb3JQb3NpdGlvbiA9IGN1cnNvclBvc2l0aW9uICsgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aDtcblxuICBpZiAoY3Vyc29yUG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICBjdXJzb3JQb3NpdGlvbiA9IG1hc2subGVuZ3RoO1xuICB9IGVsc2UgaWYgKGN1cnNvclBvc2l0aW9uIDwgcHJlZml4Lmxlbmd0aCAmJiAhZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCkge1xuICAgIGN1cnNvclBvc2l0aW9uID0gcHJlZml4Lmxlbmd0aDtcbiAgfSBlbHNlIGlmIChjdXJzb3JQb3NpdGlvbiA+PSBwcmVmaXgubGVuZ3RoICYmIGN1cnNvclBvc2l0aW9uIDwgbGFzdEVkaXRhYmxlUG9zaXRpb24gJiYgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCkge1xuICAgIGN1cnNvclBvc2l0aW9uID0gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKG1hc2tPcHRpb25zLCBjdXJzb3JQb3NpdGlvbik7XG4gIH1cblxuICBuZXdWYWx1ZSA9IGZvcm1hdFZhbHVlKG1hc2tPcHRpb25zLCBuZXdWYWx1ZSk7XG5cbiAgaWYgKCFlbnRlcmVkU3RyaW5nKSB7XG4gICAgZW50ZXJlZFN0cmluZyA9IG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICBlbnRlcmVkU3RyaW5nOiBlbnRlcmVkU3RyaW5nLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgc3RhcnQ6IGN1cnNvclBvc2l0aW9uLFxuICAgICAgZW5kOiBjdXJzb3JQb3NpdGlvblxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNXaW5kb3dzUGhvbmVCcm93c2VyKCkge1xuICB2YXIgd2luZG93cyA9IG5ldyBSZWdFeHAoJ3dpbmRvd3MnLCAnaScpO1xuICB2YXIgcGhvbmUgPSBuZXcgUmVnRXhwKCdwaG9uZScsICdpJyk7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiB3aW5kb3dzLnRlc3QodWEpICYmIHBob25lLnRlc3QodWEpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRDYW5jZWxBbmltYXRpb25GcmFtZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlZmVyKGZuKSB7XG4gIHZhciBoYXNDYW5jZWxBbmltYXRpb25GcmFtZSA9ICEhZ2V0Q2FuY2VsQW5pbWF0aW9uRnJhbWUoKTtcbiAgdmFyIGRlZmVyRm47XG5cbiAgaWYgKGhhc0NhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZGVmZXJGbiA9IGdldFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuICB9IGVsc2Uge1xuICAgIGRlZmVyRm4gPSBmdW5jdGlvbiBkZWZlckZuKCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDEwMDAgLyA2MCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkZWZlckZuKGZuKTtcbn1cbmZ1bmN0aW9uIGNhbmNlbERlZmVyKGRlZmVySWQpIHtcbiAgdmFyIGNhbmNlbEZuID0gZ2V0Q2FuY2VsQW5pbWF0aW9uRnJhbWUoKSB8fCBjbGVhclRpbWVvdXQ7XG4gIGNhbmNlbEZuKGRlZmVySWQpO1xufVxuXG52YXIgSW5wdXRFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKElucHV0RWxlbWVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSW5wdXRFbGVtZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIF90aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5wcmV2aW91c1NlbGVjdGlvbiA9IG51bGw7XG4gICAgX3RoaXMuc2VsZWN0aW9uRGVmZXJJZCA9IG51bGw7XG4gICAgX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkID0gbnVsbDtcblxuICAgIF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucHJldmlvdXNTZWxlY3Rpb24gPSBfdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCA9IGRlZmVyKF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucnVuU2F2ZVNlbGVjdGlvbkxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkID09PSBudWxsKSB7XG4gICAgICAgIF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnN0b3BTYXZlU2VsZWN0aW9uTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsRGVmZXIoX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkKTtcbiAgICAgICAgX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkID0gbnVsbDtcbiAgICAgICAgX3RoaXMucHJldmlvdXNTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRJbnB1dERPTU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IHJlYWN0RG9tLmZpbmRET01Ob2RlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICAgIHZhciBpc0RPTU5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBpbnB1dCBpbnN0YW5jZW9mIHdpbmRvdy5FbGVtZW50OyAvLyB3b3JrYXJvdW5kIGZvciByZWFjdC10ZXN0LXJlbmRlcmVyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fubmlhc3Npbi9yZWFjdC1pbnB1dC1tYXNrL2lzc3Vlcy8xNDdcblxuICAgICAgaWYgKGlucHV0ICYmICFpc0RPTU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dC5ub2RlTmFtZSAhPT0gJ0lOUFVUJykge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjdC1pbnB1dC1tYXNrOiBpbnB1dENvbXBvbmVudCBkb2VzblxcJ3QgY29udGFpbiBpbnB1dCBub2RlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0RE9NTm9kZSgpO1xuXG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgfTtcblxuICAgIF90aGlzLnNldElucHV0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0RE9NTm9kZSgpO1xuXG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIF90aGlzLnNldEN1cnNvclRvRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpbGxlZExlbmd0aCA9IGdldEZpbGxlZExlbmd0aChfdGhpcy5tYXNrT3B0aW9ucywgX3RoaXMudmFsdWUpO1xuICAgICAgdmFyIHBvcyA9IGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihfdGhpcy5tYXNrT3B0aW9ucywgZmlsbGVkTGVuZ3RoKTtcblxuICAgICAgaWYgKHBvcyAhPT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5zZXRDdXJzb3JQb3NpdGlvbihwb3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0RE9NTm9kZSgpO1xuXG4gICAgICB2YXIgaXNGb2N1c2VkID0gX3RoaXMuaXNGb2N1c2VkKCk7IC8vIGRvbid0IGNoYW5nZSBzZWxlY3Rpb24gb24gdW5mb2N1c2VkIGlucHV0XG4gICAgICAvLyBiZWNhdXNlIFNhZmFyaSBzZXRzIGZvY3VzIG9uIHNlbGVjdGlvbiBjaGFuZ2UgKCMxNTQpXG5cblxuICAgICAgaWYgKCFpbnB1dCB8fCAhaXNGb2N1c2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgICBkZWZlcnJlZCA9IF9vcHRpb25zLmRlZmVycmVkO1xuXG4gICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgIHNldElucHV0U2VsZWN0aW9uKGlucHV0LCBzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnNlbGVjdGlvbkRlZmVySWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsRGVmZXIoX3RoaXMuc2VsZWN0aW9uRGVmZXJJZCk7XG4gICAgICB9IC8vIGRlZmVycmVkIHNlbGVjdGlvbiB1cGRhdGUgaXMgcmVxdWlyZWQgZm9yIHByZS1Mb2xsaXBvcCBBbmRyb2lkIGJyb3dzZXIsXG4gICAgICAvLyBidXQgZm9yIGNvbnNpc3RlbnQgYmVoYXZpb3Igd2UgZG8gaXQgZm9yIGFsbCBicm93c2Vyc1xuXG5cbiAgICAgIF90aGlzLnNlbGVjdGlvbkRlZmVySWQgPSBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNlbGVjdGlvbkRlZmVySWQgPSBudWxsO1xuICAgICAgICBzZXRJbnB1dFNlbGVjdGlvbihpbnB1dCwgc3RhcnQsIGVuZCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLnByZXZpb3VzU2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBsZW5ndGg6IE1hdGguYWJzKGVuZCAtIHN0YXJ0KVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlucHV0ID0gX3RoaXMuZ2V0SW5wdXRET01Ob2RlKCk7XG5cbiAgICAgIHJldHVybiBnZXRJbnB1dFNlbGVjdGlvbihpbnB1dCk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldEN1cnNvclBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldFNlbGVjdGlvbigpLnN0YXJ0O1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRDdXJzb3JQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIF90aGlzLnNldFNlbGVjdGlvbihwb3MsIHBvcyk7XG4gICAgfTtcblxuICAgIF90aGlzLmlzRm9jdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5mb2N1c2VkO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRtYXNrT3B0aW9ucyA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgICAgIG1hc2tDaGFyID0gX3RoaXMkbWFza09wdGlvbnMubWFza0NoYXIsXG4gICAgICAgICAgcGVybWFuZW50cyA9IF90aGlzJG1hc2tPcHRpb25zLnBlcm1hbmVudHMsXG4gICAgICAgICAgZm9ybWF0Q2hhcnMgPSBfdGhpcyRtYXNrT3B0aW9ucy5mb3JtYXRDaGFycztcbiAgICAgIHZhciBhbHdheXNTaG93TWFzayA9IF90aGlzLnByb3BzLmFsd2F5c1Nob3dNYXNrO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFzazogbWFzayxcbiAgICAgICAgbWFza0NoYXI6IG1hc2tDaGFyLFxuICAgICAgICBwZXJtYW5lbnRzOiBwZXJtYW5lbnRzLFxuICAgICAgICBhbHdheXNTaG93TWFzazogISFhbHdheXNTaG93TWFzayxcbiAgICAgICAgZm9ybWF0Q2hhcnM6IGZvcm1hdENoYXJzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5pc0lucHV0QXV0b2ZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VsZWN0aW9uLCBwcmV2aW91c1ZhbHVlLCBwcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgdmFyIGlucHV0ID0gX3RoaXMuZ2V0SW5wdXRET01Ob2RlKCk7IC8vIG9ubHkgY2hlY2sgZm9yIHBvc2l0aXZlIG1hdGNoIGJlY2F1c2UgaXQgd2lsbCBiZSBmYWxzZSBuZWdhdGl2ZVxuICAgICAgLy8gaW4gY2FzZSBvZiBhdXRvZmlsbCBzaW11bGF0aW9uIGluIHRlc3RzXG4gICAgICAvL1xuICAgICAgLy8gaW5wdXQubWF0Y2hlcyB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHNlbGVjdG9yIGlzbid0IHN1cHBvcnRlZFxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaGVzKCc6LXdlYmtpdC1hdXRvZmlsbCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGlmIGlucHV0IGlzbid0IGZvY3VzZWQgdGhlbiBjaGFuZ2UgZXZlbnQgbXVzdCBoYXZlIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAvLyBlaXRoZXIgYnkgYXV0b2ZpbGwgb3IgZXZlbnQgc2ltdWxhdGlvbiBpbiB0ZXN0c1xuXG5cbiAgICAgIGlmICghX3RoaXMuZm9jdXNlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gaWYgY3Vyc29yIGhhcyBtb3ZlZCB0byB0aGUgZW5kIHdoaWxlIHByZXZpb3VzU2VsZWN0aW9uIGZvcmJpZHMgaXRcbiAgICAgIC8vIHRoZW4gaXQgbXVzdCBiZSBhdXRvZmlsbFxuXG5cbiAgICAgIHJldHVybiBwcmV2aW91c1NlbGVjdGlvbi5lbmQgPCBwcmV2aW91c1ZhbHVlLmxlbmd0aCAmJiBzZWxlY3Rpb24uZW5kID09PSB2YWx1ZS5sZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgICAgYmVmb3JlUGFzdGVTdGF0ZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZS5iZWZvcmVQYXN0ZVN0YXRlO1xuXG4gICAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplMiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICAgIHByZXZpb3VzU2VsZWN0aW9uID0gX2Fzc2VydFRoaXNJbml0aWFsaXplMi5wcmV2aW91c1NlbGVjdGlvbjtcblxuICAgICAgdmFyIGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gX3RoaXMucHJvcHMuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2U7XG5cbiAgICAgIHZhciB2YWx1ZSA9IF90aGlzLmdldElucHV0VmFsdWUoKTtcblxuICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBfdGhpcy52YWx1ZTtcblxuICAgICAgdmFyIHNlbGVjdGlvbiA9IF90aGlzLmdldFNlbGVjdGlvbigpOyAvLyBhdXRvZmlsbCByZXBsYWNlcyBlbnRpcmUgdmFsdWUsIGlnbm9yZSBvbGQgb25lXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fubmlhc3Npbi9yZWFjdC1pbnB1dC1tYXNrL2lzc3Vlcy8xMTNcblxuXG4gICAgICBpZiAoX3RoaXMuaXNJbnB1dEF1dG9maWxsZWQodmFsdWUsIHNlbGVjdGlvbiwgcHJldmlvdXNWYWx1ZSwgcHJldmlvdXNTZWxlY3Rpb24pKSB7XG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBmb3JtYXRWYWx1ZShfdGhpcy5tYXNrT3B0aW9ucywgJycpO1xuICAgICAgICBwcmV2aW91c1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH07XG4gICAgICB9IC8vIHNldCB2YWx1ZSBhbmQgc2VsZWN0aW9uIGFzIGlmIHdlIGhhdmVuJ3RcbiAgICAgIC8vIGNsZWFyZWQgaW5wdXQgaW4gb25QYXN0ZSBoYW5kbGVyXG5cblxuICAgICAgaWYgKGJlZm9yZVBhc3RlU3RhdGUpIHtcbiAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24gPSBiZWZvcmVQYXN0ZVN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGJlZm9yZVBhc3RlU3RhdGUudmFsdWU7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgKyB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgZW5kOiBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCArIHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWUgPSBwcmV2aW91c1ZhbHVlLnNsaWNlKDAsIHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0KSArIHZhbHVlICsgcHJldmlvdXNWYWx1ZS5zbGljZShwcmV2aW91c1NlbGVjdGlvbi5lbmQpO1xuICAgICAgICBfdGhpcy5iZWZvcmVQYXN0ZVN0YXRlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWRTdGF0ZSA9IHByb2Nlc3NDaGFuZ2UoX3RoaXMubWFza09wdGlvbnMsIHZhbHVlLCBzZWxlY3Rpb24sIHByZXZpb3VzVmFsdWUsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgIHZhciBlbnRlcmVkU3RyaW5nID0gY2hhbmdlZFN0YXRlLmVudGVyZWRTdHJpbmc7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gY2hhbmdlZFN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZWRTdGF0ZS52YWx1ZTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2Uoe1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgICB9LCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uOiBwcmV2aW91c1NlbGVjdGlvblxuICAgICAgICB9LCBlbnRlcmVkU3RyaW5nLCBfdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZygpKTtcbiAgICAgICAgbmV3VmFsdWUgPSBtb2RpZmllZFZhbHVlLnZhbHVlO1xuICAgICAgICBuZXdTZWxlY3Rpb24gPSBtb2RpZmllZFZhbHVlLnNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0SW5wdXRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uQ2hhbmdlKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pc1dpbmRvd3NQaG9uZUJyb3dzZXIpIHtcbiAgICAgICAgX3RoaXMuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbi5zdGFydCwgbmV3U2VsZWN0aW9uLmVuZCwge1xuICAgICAgICAgIGRlZmVycmVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbi5zdGFydCwgbmV3U2VsZWN0aW9uLmVuZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IF90aGlzLnByb3BzLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlO1xuICAgICAgdmFyIF90aGlzJG1hc2tPcHRpb25zMiA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICAgIG1hc2sgPSBfdGhpcyRtYXNrT3B0aW9uczIubWFzayxcbiAgICAgICAgICBwcmVmaXggPSBfdGhpcyRtYXNrT3B0aW9uczIucHJlZml4O1xuICAgICAgX3RoaXMuZm9jdXNlZCA9IHRydWU7IC8vIGlmIGF1dG9Gb2N1cyBpcyBzZXQsIG9uRm9jdXMgdHJpZ2dlcnMgYmVmb3JlIGNvbXBvbmVudERpZE1vdW50XG5cbiAgICAgIF90aGlzLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAobWFzaykge1xuICAgICAgICBpZiAoIV90aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdmFyIGVtcHR5VmFsdWUgPSBmb3JtYXRWYWx1ZShfdGhpcy5tYXNrT3B0aW9ucywgcHJlZml4KTtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBmb3JtYXRWYWx1ZShfdGhpcy5tYXNrT3B0aW9ucywgZW1wdHlWYWx1ZSk7XG4gICAgICAgICAgdmFyIGZpbGxlZExlbmd0aCA9IGdldEZpbGxlZExlbmd0aChfdGhpcy5tYXNrT3B0aW9ucywgbmV3VmFsdWUpO1xuICAgICAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihfdGhpcy5tYXNrT3B0aW9ucywgZmlsbGVkTGVuZ3RoKTtcbiAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGN1cnNvclBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBjdXJzb3JQb3NpdGlvblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSkpIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2Uoe1xuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgICAgICB9LCBudWxsLCBfdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZygpKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbW9kaWZpZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IG1vZGlmaWVkVmFsdWUuc2VsZWN0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0lucHV0VmFsdWVDaGFuZ2VkID0gbmV3VmFsdWUgIT09IF90aGlzLmdldElucHV0VmFsdWUoKTtcblxuICAgICAgICAgIGlmIChpc0lucHV0VmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRJbnB1dFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNJbnB1dFZhbHVlQ2hhbmdlZCAmJiBpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uQ2hhbmdlKSkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24uc3RhcnQsIG5ld1NlbGVjdGlvbi5lbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKGdldEZpbGxlZExlbmd0aChfdGhpcy5tYXNrT3B0aW9ucywgX3RoaXMudmFsdWUpIDwgX3RoaXMubWFza09wdGlvbnMubWFzay5sZW5ndGgpIHtcbiAgICAgICAgICBfdGhpcy5zZXRDdXJzb3JUb0VuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucnVuU2F2ZVNlbGVjdGlvbkxvb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25Gb2N1cykpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Gb2N1cyhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gX3RoaXMucHJvcHMuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2U7XG4gICAgICB2YXIgbWFzayA9IF90aGlzLm1hc2tPcHRpb25zLm1hc2s7XG5cbiAgICAgIF90aGlzLnN0b3BTYXZlU2VsZWN0aW9uTG9vcCgpO1xuXG4gICAgICBfdGhpcy5mb2N1c2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChtYXNrICYmICFfdGhpcy5wcm9wcy5hbHdheXNTaG93TWFzayAmJiBpc0VtcHR5KF90aGlzLm1hc2tPcHRpb25zLCBfdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gJyc7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMudmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb246IF90aGlzLnByZXZpb3VzU2VsZWN0aW9uXG4gICAgICAgICAgfSwgbnVsbCwgX3RoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcoKSk7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtb2RpZmllZFZhbHVlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzSW5wdXRWYWx1ZUNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gX3RoaXMuZ2V0SW5wdXRWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChpc0lucHV0VmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgX3RoaXMuc2V0SW5wdXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbnB1dFZhbHVlQ2hhbmdlZCAmJiBpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uQ2hhbmdlKSkge1xuICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbkJsdXIpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQmx1cihldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyB0aW55IHVuaW50ZW50aW9uYWwgbW91c2UgbW92ZW1lbnRzIGNhbiBicmVhayBjdXJzb3JcbiAgICAgIC8vIHBvc2l0aW9uIG9uIGZvY3VzLCBzbyB3ZSBoYXZlIHRvIHJlc3RvcmUgaXQgaW4gdGhhdCBjYXNlXG4gICAgICAvL1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTA4XG4gICAgICBpZiAoIV90aGlzLmZvY3VzZWQgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBfdGhpcy5tb3VzZURvd25YID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgX3RoaXMubW91c2VEb3duWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIF90aGlzLm1vdXNlRG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcihtb3VzZVVwRXZlbnQpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgICAgICAgaWYgKCFfdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlbHRhWCA9IE1hdGguYWJzKG1vdXNlVXBFdmVudC5jbGllbnRYIC0gX3RoaXMubW91c2VEb3duWCk7XG4gICAgICAgICAgdmFyIGRlbHRhWSA9IE1hdGguYWJzKG1vdXNlVXBFdmVudC5jbGllbnRZIC0gX3RoaXMubW91c2VEb3duWSk7XG4gICAgICAgICAgdmFyIGF4aXNEZWx0YSA9IE1hdGgubWF4KGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF90aGlzLm1vdXNlRG93blRpbWU7XG5cbiAgICAgICAgICBpZiAoYXhpc0RlbHRhIDw9IDEwICYmIHRpbWVEZWx0YSA8PSAyMDAgfHwgYXhpc0RlbHRhIDw9IDUgJiYgdGltZURlbHRhIDw9IDMwMCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0Q3Vyc29yVG9FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25Nb3VzZURvd24pKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25QYXN0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25QYXN0ZSkpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25QYXN0ZShldmVudCk7XG4gICAgICB9IC8vIGV2ZW50LmNsaXBib2FyZERhdGEgbWlnaHQgbm90IHdvcmsgaW4gQW5kcm9pZCBicm93c2VyXG4gICAgICAvLyBjbGVhbmluZyBpbnB1dCB0byBnZXQgcmF3IHRleHQgaW5zaWRlIG9uQ2hhbmdlIGhhbmRsZXJcblxuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgX3RoaXMuYmVmb3JlUGFzdGVTdGF0ZSA9IHtcbiAgICAgICAgICB2YWx1ZTogX3RoaXMuZ2V0SW5wdXRWYWx1ZSgpLFxuICAgICAgICAgIHNlbGVjdGlvbjogX3RoaXMuZ2V0U2VsZWN0aW9uKClcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5zZXRJbnB1dFZhbHVlKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5pbnB1dFJlZikpIHtcbiAgICAgICAgX3RoaXMucHJvcHMuaW5wdXRSZWYocmVmKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXNrID0gcHJvcHMubWFzayxcbiAgICAgICAgX21hc2tDaGFyID0gcHJvcHMubWFza0NoYXIsXG4gICAgICAgIF9mb3JtYXRDaGFycyA9IHByb3BzLmZvcm1hdENoYXJzLFxuICAgICAgICBfYWx3YXlzU2hvd01hc2sgPSBwcm9wcy5hbHdheXNTaG93TWFzayxcbiAgICAgICAgX2JlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gcHJvcHMuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2U7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX3ZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgX3RoaXMubWFza09wdGlvbnMgPSBwYXJzZU1hc2soX21hc2ssIF9tYXNrQ2hhciwgX2Zvcm1hdENoYXJzKTtcblxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICBfdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIF9uZXdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKF92YWx1ZSk7XG5cbiAgICBpZiAoX3RoaXMubWFza09wdGlvbnMubWFzayAmJiAoX2Fsd2F5c1Nob3dNYXNrIHx8IF9uZXdWYWx1ZSkpIHtcbiAgICAgIF9uZXdWYWx1ZSA9IGZvcm1hdFZhbHVlKF90aGlzLm1hc2tPcHRpb25zLCBfbmV3VmFsdWUpO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihfYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgb2xkVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKG9sZFZhbHVlKTtcblxuICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IF9iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSh7XG4gICAgICAgICAgdmFsdWU6IF9uZXdWYWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgIHZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfSwgbnVsbCwgX3RoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcoKSk7XG5cbiAgICAgICAgX25ld1ZhbHVlID0gbW9kaWZpZWRWYWx1ZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy52YWx1ZSA9IF9uZXdWYWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW5wdXRFbGVtZW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlOyAvLyB3b3JrYXJvdW5kIGZvciByZWFjdC10ZXN0LXJlbmRlcmVyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTQ3XG5cbiAgICBpZiAoIXRoaXMuZ2V0SW5wdXRET01Ob2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzV2luZG93c1Bob25lQnJvd3NlciA9IGlzV2luZG93c1Bob25lQnJvd3NlcigpO1xuXG4gICAgaWYgKHRoaXMubWFza09wdGlvbnMubWFzayAmJiB0aGlzLmdldElucHV0VmFsdWUoKSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IHRoaXMucHJldmlvdXNTZWxlY3Rpb247XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBfdGhpcyRwcm9wcy5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSxcbiAgICAgICAgYWx3YXlzU2hvd01hc2sgPSBfdGhpcyRwcm9wcy5hbHdheXNTaG93TWFzayxcbiAgICAgICAgbWFzayA9IF90aGlzJHByb3BzLm1hc2ssXG4gICAgICAgIG1hc2tDaGFyID0gX3RoaXMkcHJvcHMubWFza0NoYXIsXG4gICAgICAgIGZvcm1hdENoYXJzID0gX3RoaXMkcHJvcHMuZm9ybWF0Q2hhcnM7XG4gICAgdmFyIHByZXZpb3VzTWFza09wdGlvbnMgPSB0aGlzLm1hc2tPcHRpb25zO1xuICAgIHZhciBzaG93RW1wdHkgPSBhbHdheXNTaG93TWFzayB8fCB0aGlzLmlzRm9jdXNlZCgpO1xuICAgIHZhciBoYXNWYWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgIT0gbnVsbDtcbiAgICB2YXIgbmV3VmFsdWUgPSBoYXNWYWx1ZSA/IGdldFN0cmluZ1ZhbHVlKHRoaXMucHJvcHMudmFsdWUpIDogdGhpcy52YWx1ZTtcbiAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBwcmV2aW91c1NlbGVjdGlvbiA/IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0IDogbnVsbDtcbiAgICB0aGlzLm1hc2tPcHRpb25zID0gcGFyc2VNYXNrKG1hc2ssIG1hc2tDaGFyLCBmb3JtYXRDaGFycyk7XG5cbiAgICBpZiAoIXRoaXMubWFza09wdGlvbnMubWFzaykge1xuICAgICAgaWYgKHByZXZpb3VzTWFza09wdGlvbnMubWFzaykge1xuICAgICAgICB0aGlzLnN0b3BTYXZlU2VsZWN0aW9uTG9vcCgpOyAvLyByZW5kZXIgZGVwZW5kcyBvbiB0aGlzLm1hc2tPcHRpb25zIGFuZCB0aGlzLnZhbHVlLFxuICAgICAgICAvLyBjYWxsIGZvcmNlVXBkYXRlIHRvIGtlZXAgaXQgaW4gc3luY1xuXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIXByZXZpb3VzTWFza09wdGlvbnMubWFzayAmJiB0aGlzLmlzRm9jdXNlZCgpKSB7XG4gICAgICB0aGlzLnJ1blNhdmVTZWxlY3Rpb25Mb29wKCk7XG4gICAgfVxuXG4gICAgdmFyIGlzTWFza0NoYW5nZWQgPSB0aGlzLm1hc2tPcHRpb25zLm1hc2sgJiYgdGhpcy5tYXNrT3B0aW9ucy5tYXNrICE9PSBwcmV2aW91c01hc2tPcHRpb25zLm1hc2s7XG5cbiAgICBpZiAoIXByZXZpb3VzTWFza09wdGlvbnMubWFzayAmJiAhaGFzVmFsdWUpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5nZXRJbnB1dFZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFza0NoYW5nZWQgfHwgdGhpcy5tYXNrT3B0aW9ucy5tYXNrICYmIChuZXdWYWx1ZSB8fCBzaG93RW1wdHkpKSB7XG4gICAgICBuZXdWYWx1ZSA9IGZvcm1hdFZhbHVlKHRoaXMubWFza09wdGlvbnMsIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXNrQ2hhbmdlZCkge1xuICAgICAgdmFyIGZpbGxlZExlbmd0aCA9IGdldEZpbGxlZExlbmd0aCh0aGlzLm1hc2tPcHRpb25zLCBuZXdWYWx1ZSk7XG5cbiAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiA9PT0gbnVsbCB8fCBmaWxsZWRMZW5ndGggPCBjdXJzb3JQb3NpdGlvbikge1xuICAgICAgICBpZiAoaXNGaWxsZWQodGhpcy5tYXNrT3B0aW9ucywgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgY3Vyc29yUG9zaXRpb24gPSBmaWxsZWRMZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Vyc29yUG9zaXRpb24gPSBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24odGhpcy5tYXNrT3B0aW9ucywgZmlsbGVkTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1hc2tPcHRpb25zLm1hc2sgJiYgaXNFbXB0eSh0aGlzLm1hc2tPcHRpb25zLCBuZXdWYWx1ZSkgJiYgIXNob3dFbXB0eSAmJiAoIWhhc1ZhbHVlIHx8ICF0aGlzLnByb3BzLnZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgbmV3U2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGN1cnNvclBvc2l0aW9uLFxuICAgICAgZW5kOiBjdXJzb3JQb3NpdGlvblxuICAgIH07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSkpIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2Uoe1xuICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb246IHRoaXMucHJldmlvdXNTZWxlY3Rpb25cbiAgICAgIH0sIG51bGwsIHRoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcoKSk7XG4gICAgICBuZXdWYWx1ZSA9IG1vZGlmaWVkVmFsdWUudmFsdWU7XG4gICAgICBuZXdTZWxlY3Rpb24gPSBtb2RpZmllZFZhbHVlLnNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgdmFyIGlzVmFsdWVDaGFuZ2VkID0gdGhpcy5nZXRJbnB1dFZhbHVlKCkgIT09IHRoaXMudmFsdWU7IC8vIHJlbmRlciBkZXBlbmRzIG9uIHRoaXMubWFza09wdGlvbnMgYW5kIHRoaXMudmFsdWUsXG4gICAgLy8gY2FsbCBmb3JjZVVwZGF0ZSB0byBrZWVwIGl0IGluIHN5bmNcblxuICAgIGlmIChpc1ZhbHVlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXNrQ2hhbmdlZCkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBpc1NlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcblxuICAgIGlmIChuZXdTZWxlY3Rpb24uc3RhcnQgIT0gbnVsbCAmJiBuZXdTZWxlY3Rpb24uZW5kICE9IG51bGwpIHtcbiAgICAgIGlzU2VsZWN0aW9uQ2hhbmdlZCA9ICFwcmV2aW91c1NlbGVjdGlvbiB8fCBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCAhPT0gbmV3U2VsZWN0aW9uLnN0YXJ0IHx8IHByZXZpb3VzU2VsZWN0aW9uLmVuZCAhPT0gbmV3U2VsZWN0aW9uLmVuZDtcbiAgICB9XG5cbiAgICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VkIHx8IGlzVmFsdWVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24uc3RhcnQsIG5ld1NlbGVjdGlvbi5lbmQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGlvbkRlZmVySWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbERlZmVyKHRoaXMuc2VsZWN0aW9uRGVmZXJJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wU2F2ZVNlbGVjdGlvbkxvb3AoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBtYXNrID0gX3RoaXMkcHJvcHMyLm1hc2ssXG4gICAgICAgIGFsd2F5c1Nob3dNYXNrID0gX3RoaXMkcHJvcHMyLmFsd2F5c1Nob3dNYXNrLFxuICAgICAgICBtYXNrQ2hhciA9IF90aGlzJHByb3BzMi5tYXNrQ2hhcixcbiAgICAgICAgZm9ybWF0Q2hhcnMgPSBfdGhpcyRwcm9wczIuZm9ybWF0Q2hhcnMsXG4gICAgICAgIGlucHV0UmVmID0gX3RoaXMkcHJvcHMyLmlucHV0UmVmLFxuICAgICAgICBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IF90aGlzJHByb3BzMi5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgW1wibWFza1wiLCBcImFsd2F5c1Nob3dNYXNrXCIsIFwibWFza0NoYXJcIiwgXCJmb3JtYXRDaGFyc1wiLCBcImlucHV0UmVmXCIsIFwiYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VcIiwgXCJjaGlsZHJlblwiXSk7XG5cbiAgICB2YXIgaW5wdXRFbGVtZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIC8vIHBhcnNlIG1hc2sgdG8gdGVzdCBhZ2FpbnN0IGFjdHVhbCBtYXNrIHByb3AgYXMgdGhpcy5tYXNrT3B0aW9uc1xuICAgIC8vIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpbiBjb21wb25lbnREaWRVcGRhdGVcbiAgICAhcmVzdFByb3BzLm1heExlbmd0aCB8fCAhcGFyc2VNYXNrKG1hc2ssIG1hc2tDaGFyLCBmb3JtYXRDaGFycykubWFzaywgJ3JlYWN0LWlucHV0LW1hc2s6IG1heExlbmd0aCBwcm9wZXJ0eSBzaG91bGRuXFwndCBiZSBwYXNzZWQgdG8gdGhlIG1hc2tlZCBpbnB1dC4gSXQgYnJlYWtzIG1hc2tpbmcgYW5kIHVubmVjZXNzYXJ5IGJlY2F1c2UgbGVuZ3RoIGlzIGxpbWl0ZWQgYnkgdGhlIG1hc2sgbGVuZ3RoLicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAhaXNGdW5jdGlvbihjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdyZWFjdC1pbnB1dC1tYXNrOiBjaGlsZHJlbiBtdXN0IGJlIGEgZnVuY3Rpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgY29udHJvbGxlZFByb3BzID0gWydvbkNoYW5nZScsICdvblBhc3RlJywgJ29uTW91c2VEb3duJywgJ29uRm9jdXMnLCAnb25CbHVyJywgJ3ZhbHVlJywgJ2Rpc2FibGVkJywgJ3JlYWRPbmx5J107XG5cbiAgICAgIHZhciBjaGlsZHJlblByb3BzID0gX2V4dGVuZHMoe30sIHJlc3RQcm9wcyk7XG5cbiAgICAgIGNvbnRyb2xsZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBjaGlsZHJlblByb3BzW3Byb3BJZF07XG4gICAgICB9KTtcbiAgICAgIGlucHV0RWxlbWVudCA9IGNoaWxkcmVuKGNoaWxkcmVuUHJvcHMpO1xuICAgICAgdmFyIGNvbmZsaWN0UHJvcHMgPSBjb250cm9sbGVkUHJvcHMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0RWxlbWVudC5wcm9wc1twcm9wSWRdICE9IG51bGwgJiYgaW5wdXRFbGVtZW50LnByb3BzW3Byb3BJZF0gIT09IHJlc3RQcm9wc1twcm9wSWRdO1xuICAgICAgfSk7XG4gICAgICAhIWNvbmZsaWN0UHJvcHMubGVuZ3RoID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcInJlYWN0LWlucHV0LW1hc2s6IHRoZSBmb2xsb3dpbmcgcHJvcHMgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgcmVhY3QtaW5wdXQtbWFzaydzIGNvbXBvbmVudCBhbmQgc2hvdWxkIG5vdCBiZSBhbHRlcmVkIGluIGNoaWxkcmVuJ3MgZnVuY3Rpb246IFwiICsgY29uZmxpY3RQcm9wcy5qb2luKCcsICcpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFpbnB1dFJlZiwgJ3JlYWN0LWlucHV0LW1hc2s6IGlucHV0UmVmIGlzIGlnbm9yZWQgd2hlbiBjaGlsZHJlbiBpcyBwYXNzZWQsIGF0dGFjaCByZWYgdG8gdGhlIGNoaWxkcmVuIGluc3RlYWQnKSA6IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZVJlZlxuICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRQcm9wcyA9IHtcbiAgICAgIG9uRm9jdXM6IHRoaXMub25Gb2N1cyxcbiAgICAgIG9uQmx1cjogdGhpcy5vbkJsdXJcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubWFza09wdGlvbnMubWFzaykge1xuICAgICAgaWYgKCFyZXN0UHJvcHMuZGlzYWJsZWQgJiYgIXJlc3RQcm9wcy5yZWFkT25seSkge1xuICAgICAgICBjaGFuZ2VkUHJvcHMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlO1xuICAgICAgICBjaGFuZ2VkUHJvcHMub25QYXN0ZSA9IHRoaXMub25QYXN0ZTtcbiAgICAgICAgY2hhbmdlZFByb3BzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3RQcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNoYW5nZWRQcm9wcy52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXRFbGVtZW50ID0gUmVhY3QuY2xvbmVFbGVtZW50KGlucHV0RWxlbWVudCwgY2hhbmdlZFByb3BzKTtcbiAgICByZXR1cm4gaW5wdXRFbGVtZW50O1xuICB9O1xuXG4gIHJldHVybiBJbnB1dEVsZW1lbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRFbGVtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\n");

/***/ })

};
;